

# 图像细化与骨架实践报告

<center>蒋颜丞，自动化(电气)1903，3190102563  </center>

### 1 实验内容和要求

​		自选一幅灰度图像（最好是数字、文字图像，或具有细线条的图像），编程实现以下功能：
（1）选用一种图像二值化方法，实现图像二值化，提取前景目标；
（2）基于二值形态学滤波方法，二值化结果进行形态学滤波，实现小尺度噪点去除和孔洞填充；
（3）实践一种图像细化算法，实现前景目标细化。

​		我将使用以下灰度图片完成本次实践作业：

<img src="D:\浙江大学\课程\2022春夏课程\数字图像处理与机器视觉\CVprojects\Project5\report\siling3.png" alt="siling3" style="zoom:80%;" />



### 2 实验原理

#### 2.1 Otsu法（大津法）

Otsu法是阈值化中常用的自动确定阈值的方法之一。Otsu法确定最佳阈值的准则是使阈值分割后各个像素类的类内方差最小。另一种确定阈值的准则是使得阈值分割后的像素类的类间方差最大。这两种准则是等价的，因为类间方差与类内方差之和即整幅图像的方差，是一个常数。分割的目的就是要使类别之间的差别最大，类内之间的差别最小。

设图像总像素数为$N$，灰度级总数为$L$，灰度值为i的像素数为$N_i$。令$\omega(k)$和$μ(k)$分别表示从灰度级0到灰度级k的像素的出现概率和平均灰度，分别表示为
$$
w(k)=\sum_{i=0}^{k}\frac{N_i}{N}\\
\mu(k)=\sum_{i=0}^{k}\frac{i\cdot N_i}{N}
$$
由此可见，所有像素的总概率为$ω(L-1)=1$，图像的平均灰度为$μ_T=μ(L-1)$。 

设有*M*-1个阈值($0≤t_1＜t_2＜…＜t_{M-1}≤L-1$)，将图像分成$M$个像素类$C_j$($C_j\in［t_{j-1}+1,…,t_j$］； $j=1,2,…,M$； $t_0=0$，$t_M=L-1$)，则$C_j$的出现概率$ω_j$、平均灰度$μ_j$和方差$\sigma_j^2$为
$$
\omega_j=\omega(t_j)-\omega(t_{j-1})\\
\mu_j=\frac{\mu(t_j)-\mu(t_{j-1})}{\omega(t_j)-\omega(t_{j-1})}\\
\sigma_j^2=\sum_{i=t_{j-1}+1}^{t_j}(i-\mu_j)^2\frac{\omega(i)}{\omega_j}
$$
由此可得类内方差为

$$
\sigma_W^2(t_1,t_2, …,t_{M－1})=\sum_{j=1}^{M}\omega_j*\sigma_j^2
$$
各类的类间方差为

$$
\sigma_B^2(t_1,t_2, …,t_{M－1})=\sum_{j=1}^{M}\omega_j*(\mu_j-\mu_T)^2
$$
将使$(*)$式最小或使$(\#)$式最大的阈值组($t_1,t_2, …,t_{M－1}$)作为M阈值化的最佳阈值组。若取$M$为2，即分割成2类，则可用上述方法求出二值化的最佳阈值。




#### 2.2 形态学滤波

##### 2.2.1 腐蚀



##### 2.2.2 膨胀



##### 2.2.3 开运算



##### 2.2.4 闭运算



#### 2.3 图像细化

利用前面所介绍的形态学知识，下面给出一种实用的对二值区域进行形态学细化的一种算法。如前所述，一个图像的“骨架”， 是指图像中央的骨骼部分，是描述图像几何及拓扑性质的重要特征之一。求一幅图像骨架的过程就是对图像进行“细化”的过程。在文字识别、地质构造识别、工业零件形状识别或图像理解中， 先对被处理的图像进行细化有助于突出形状特点和减少冗余信息量。

根据8.4.2节中骨架和细化的定义以及式（8-30）、 式（8-32）和式（8-35）等可以看到，在细化一幅图像X时**应满足两个条件**： 第一， 在细化的过程中， X应该有规律地缩小； 第二，在X逐步缩小的过程中， 应当使X的连通性质保持不变。下面介绍一个具体的细化算法。

设已知目标点标记为1，背景点标记为0。**边界点**是指本身标记为1而其8连通邻域中至少有一个标记为0的点。算法对一幅图像的所有边界点即一个3×3区域都进行如下检验和操作：

(1) 考虑以边界点为中心的8邻域，设$p_1$为中心点，对其邻域的8个点逆时针绕中心点分别标记为$p_2,p_3,…,p_9$，其中$p_2$位于$p_1$的上方。如果$p_1=1$(即黑点)时，下面4个条件同时满足，则标记$p_1$为删除点(最后统一删除)： 

① $2≤N(p_1)≤6$，其中$N(p_1)$是$p_1$的非零邻点的个数；

② $S(p_1)=1$，其中$S(p_1)$是以$p_2,p_3,p_4,…,p_9$为序时这些点的值从0到1变化的次数；

③ $p_2p_6p_8=0$； 

④ $p_4p_6p_8=0$。 

(2) 同第(1)步，仅将③中的条件改为$p_2p_4p_6=0$，④中的条件改为$p_2p_4p_8=0$。同样当对所有边界点都检验完毕后，将所有满足条件的点删除。

以上两步操作构成一次迭代。算法反复迭代，直至没有点再满足标记删除的条件，这时剩下的点就组成区域的骨架。



### 3 源代码









### 4 实验结果与分析

#### 4.1 实验结果





#### 4.2 实验分析

